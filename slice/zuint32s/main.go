// Code generated by z. DO NOT EDIT.

package zuint32s

import "errors"

var (
	ErrInterfaceNotUint32 = errors.New("encountered non-uint32 interface")
)

func Equal(a []uint32, b []uint32) bool {
  if len(a) != len(b) {
    return false
  }
  for i := range a {
    if a[i] != b[i] {
      return false
    }
  }
  return true
}

// Check if a slice ([]uint32) contains a matching member
func Contains(haystack []uint32, needle uint32) bool {
	for _, val := range haystack {
		if needle == val {
			return true
		}
	}
	return false
}

// Check if a []uint32 slice contains ANY of the provided members
func ContainsAny(haystack []uint32, needles ...uint32) bool {
  for _, needle := range needles {
    if Contains(haystack, needle) {
      return true
    }
  }
  return false
}

// Check if a []uint32 slice contains ALL of the provided members
func ContainsAll(haystack []uint32, needles ...uint32) bool {
  for _, needle := range needles {
    if !Contains(haystack, needle) {
      return false
    }
  }
  return true
}

// Convert a []interface{} slice into []uint32 slice if possible
func As(slice []interface{}) (res []uint32, err error) {
	res = make([]uint32, len(slice))
	for i := range slice {
		if strVal, ok := slice[i].(uint32); !ok {
			return res, ErrInterfaceNotUint32
		} else {
			res[i] = strVal
		}
	}
	return
}

// Convert a []uint32 slice into a slice of interfaces ([]interface{})
func Interface(slice []uint32) (res []interface{}, err error) {
	res = make([]interface{}, len(slice))
	for i := range slice {
		res[i] = slice[i]
	}
	return
}

// Find the index where the needle appears. Returns -1 if the needle doesn't 
// appear in the slice.
func Index(haystack []uint32, needle uint32) int {
  for i := range haystack {
    if haystack[i] == needle {
      return i
    }
  }
  return -1
}

// Cut the slice into two slices separated by the separator
func Cut(slice []uint32, separator uint32) (left, right []uint32, found bool) {
	if i := Index(slice, separator); i >= 0 {
		return slice[:i], slice[i+1:], true
	}
	return slice, nil, false
}

// Cut the slice into two slices separated by the first separator
func CutAny(val []uint32, seperators ...uint32) (left, right []uint32, found bool) {
	for _, sep := range seperators {
		left, right, found = Cut(val, sep)
		if found {
			return
		}
	}
	return
}

// Split the slice into one or more slices separated by the separator
func Split(slice []uint32, separator uint32) (parts [][]uint32) {
  prevI := 0
  for i := range slice {
    if slice[i] == separator {
      if i > prevI {
        parts = append(parts, slice[prevI:i])
      }
      prevI = i + 1
    }
  }
  if len(slice) > prevI {
    parts = append(parts, slice[prevI:])
  }
  return
}

// // Split the slice into one or more slices using multiple separators
// func SplitMany(slice []uint32, seperators ...uint32) (parts [][]uint32) {
// 	parts = append(parts, slice)
// 	for _, sep := range seperators {
// 		for i, part := range parts {
// 			vals := Split(part, sep)
// 			if len(vals) > 1 {
// 				// Replace existing element with all vals
// 				parts = append(parts[:i], append(vals, parts[i+1:]...)...)
// 			}
// 		}
// 	}
// 	return
// }

// // Merge two slices together without repeating values
// func Merge(a []uint32, b []uint32) (res []uint32) {
//   
// }

// // Remove the first occurrence of each value from the slice starting from the 
// // supplied offset
// func Remove(slice []uint32, values ...uint32, offset int) (res []uint32) {
// 
// }

// // Replace the first occurrence of a value with the replacement value
// func Replace(slice []uint32, val uint32, replacement uint32) (res []uint32) {
// 
// }

// // Replace all occurrences of a value with the replacement value
// func ReplaceAll(slice []uint32, val uint32, replacement uint32) (res []uint32) {
// 
// }
// 

